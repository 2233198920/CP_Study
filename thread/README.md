# Mutex 示例

本示例演示如何使用 `std::mutex` 来保护共享数据，避免多线程环境下的数据竞争问题。
示例中创建多个线程，对共享计数器执行累加操作，每次操作均通过 mutex 进行同步保护。

## Mutex 成员函数说明

- lock(): 获取互斥量，如果已被其他线程锁定则等待
- unlock(): 释放当前线程持有的互斥量
- try_lock(): 尝试获取互斥量，若成功返回 true，否则返回 false
- lock_guard()：用法：std::lock_guard<std::mutex> lck(mtx) ，构造时自动调用传入互斥量的 lock() 方法，加锁互斥量（比如 mtx）。析构时自动调用互斥量的 unlock() 方法，解锁互斥量。这样可以确保即使在异常情况下也能正确释放锁，从而避免死锁问题。lck就是存储构造函数与析构函数的栈，用于自动管理互斥锁的对象。
- unique_lock(): 与lock_guard()相似，其灵活性: 可手动 unlock 和 re-lock

## 条件变量（Condition Variable）说明

条件变量是一种同步机制，用于线程间的通信。主要成员函数：

- wait(): 等待条件满足
  template<class Predicate>
  void wait(std::unique_lock<std::mutex>& lck, Predicate pred);
  - 自动释放互斥量并阻塞线程
  - 被唤醒时自动重新获取互斥量

- notify_one(): 唤醒一个等待的线程
- notify_all(): 唤醒所有等待的线程

条件变量通常与互斥量配合使用，可以避免忙等待，提高程序效率。示例中实现了一个简单的生产者-消费者模型，演示了条件变量的基本用法。

## 原子变量（Atomic）说明

原子变量是一种特殊的变量类型，它的操作是原子性的，能够避免数据竞争。主要特点：

- 原子操作保证在多线程环境下的完整性，不会被打断
- 无需使用互斥量即可保证线程安全
- 常用操作：
  - load(): 原子读取值
  - store(): 原子存储值
  - exchange(): 原子交换值
  - compare_exchange_weak/strong(): 比较并交换操作

原子变量适用场景：
- 简单的计数器
- 标志位操作
- 需要线程安全但对性能要求较高的场合

### 为什么原子变量和普通变量的结果会不同？

1. 普通变量的自增操作实际包含三个步骤：
   - 从内存读取值
   - 将值加1
   - 将结果写回内存

2. 在多线程环境下可能出现以下情况：
   - 线程A读取值为100
   - 线程B同时读取值为100
   - 线程A将值加1得到101
   - 线程B将值加1得到101
   - 线程A将101写回内存
   - 线程B将101写回内存
   最终结果为101，而不是期望的102

3. 原子变量的优势：
   - 保证读取-修改-写入是一个不可分割的操作
   - 其他线程无法在该操作中途介入
   - 避免了上述竞争条件
   - 确保每个自增操作都能正确累加

这就是为什么使用原子变量的计数器能得到正确结果，而普通变量会出现计数偏小的情况。

## Future 说明

Future 是 C++ 中用于获取异步操作结果的机制。主要组件包括：

### std::future
- 用于访问异步操作的结果
- 主要方法：
  - get(): 获取结果，如果结果未就绪则阻塞等待
  - wait(): 等待结果就绪但不获取结果
  - wait_for(): 限时等待结果
  - valid(): 检查 future 是否有效


### std::async
- 用于创建异步任务
- 启动策略：
  - launch::async: 保证异步执行
  - launch::deferred: 延迟执行（首次获取结果时执行）
  - launch::async | launch::deferred: 由系统决定

使用场景：
- 需要获取线程执行结果时
- 异步计算
- 并行算法

### std::packaged_task
- 用于包装任何可调用对象（函数、lambda等）
- 可以异步执行并获取结果
- 主要特点：
  - 可以把任务的执行和结果的获取分离
  - 提供比 std::async 更细粒度的控制
  - 可以重置和重用
  - 与 std::thread 完美配合

主要操作：
- 构造：std::packaged_task<ReturnType(ArgTypes...)>
- get_future(): 获取关联的 future 对象
- operator(): 执行任务
- reset(): 重置任务状态，允许重新执行

使用场景：
- 需要更灵活地控制任务执行时机
- 任务需要重复执行
- 线程池实现
- 异步任务队列管理

### std::promise 
- 用于在线程间传递数据的通信机制
- 与 future 配对使用，实现单向数据传输
- 主要特点：
  - 一个 promise 只能设置一次值
  - 可以传递值或异常
  - 支持移动语义，但不支持拷贝

主要操作：
- set_value(): 设置结果值
- set_exception(): 设置异常
- set_value_at_thread_exit(): 在线程结束时设置值
- get_future(): 获取关联的 future 对象

